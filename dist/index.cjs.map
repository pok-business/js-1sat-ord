{"version":3,"file":"index.cjs","sources":["../node_modules/dotenv/lib/main.js","../src/utils/strings.ts","../src/index.ts"],"sourcesContent":["const fs = require('fs')\nconst path = require('path')\nconst os = require('os')\nconst packageJson = require('../package.json')\n\nconst version = packageJson.version\n\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg\n\n// Parser src into an Object\nfunction parse (src) {\n  const obj = {}\n\n  // Convert buffer to string\n  let lines = src.toString()\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n')\n\n  let match\n  while ((match = LINE.exec(lines)) != null) {\n    const key = match[1]\n\n    // Default undefined or null to empty string\n    let value = (match[2] || '')\n\n    // Remove whitespace\n    value = value.trim()\n\n    // Check if double quoted\n    const maybeQuote = value[0]\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2')\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n')\n      value = value.replace(/\\\\r/g, '\\r')\n    }\n\n    // Add to object\n    obj[key] = value\n  }\n\n  return obj\n}\n\nfunction _log (message) {\n  console.log(`[dotenv@${version}][DEBUG] ${message}`)\n}\n\nfunction _resolveHome (envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath\n}\n\n// Populates process.env from .env file\nfunction config (options) {\n  let dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding = 'utf8'\n  const debug = Boolean(options && options.debug)\n  const override = Boolean(options && options.override)\n\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = _resolveHome(options.path)\n    }\n    if (options.encoding != null) {\n      encoding = options.encoding\n    }\n  }\n\n  try {\n    // Specifying an encoding returns a string instead of a buffer\n    const parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, { encoding }))\n\n    Object.keys(parsed).forEach(function (key) {\n      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {\n        process.env[key] = parsed[key]\n      } else {\n        if (override === true) {\n          process.env[key] = parsed[key]\n        }\n\n        if (debug) {\n          if (override === true) {\n            _log(`\"${key}\" is already defined in \\`process.env\\` and WAS overwritten`)\n          } else {\n            _log(`\"${key}\" is already defined in \\`process.env\\` and was NOT overwritten`)\n          }\n        }\n      }\n    })\n\n    return { parsed }\n  } catch (e) {\n    if (debug) {\n      _log(`Failed to load ${dotenvPath} ${e.message}`)\n    }\n\n    return { error: e }\n  }\n}\n\nconst DotenvModule = {\n  config,\n  parse\n}\n\nmodule.exports.config = DotenvModule.config\nmodule.exports.parse = DotenvModule.parse\nmodule.exports = DotenvModule\n","const toHex = (asciiStr: string) => {\n  var arr1: string[] = [];\n  for (var n = 0, l = asciiStr.length; n < l; n++) {\n    var hex = Number(asciiStr.charCodeAt(n)).toString(16);\n    arr1.push(hex);\n  }\n  return arr1.join(\"\");\n};\n\nconst toAscii = (hexStr: string) => {\n  var hex, i;\n\n  var result = \"\";\n  for (i = 0; i < hexStr.length; i++) {\n    hex = hexStr.charCodeAt(i).toString(16);\n    result += (\"000\" + hex).slice(-4);\n  }\n\n  return result;\n};\n\nexport { toHex, toAscii };\n","import {\n  P2PKHAddress,\n  PrivateKey,\n  Script,\n  SigHash,\n  Transaction,\n  TxIn,\n  TxOut,\n} from \"bsv-wasm\";\nimport { Buffer } from \"buffer\";\nimport * as dotenv from \"dotenv\";\nimport { AuthToken, Sigma } from \"sigma-protocol\";\nimport { toHex } from \"./utils/strings\";\n\ndotenv.config();\n\ntype Signer = {};\n\nexport interface LocalSigner extends Signer {\n  idKey: PrivateKey;\n}\n\nexport interface RemoteSigner extends Signer {\n  keyHost: string;\n  authToken?: AuthToken;\n}\n\nexport type Utxo = {\n  satoshis: number;\n  txid: string;\n  vout: number;\n  script: string;\n};\n\nexport type Inscription = {\n  dataB64: string;\n  contentType: string;\n};\n\nexport type MAP = {\n  app: string;\n  type: string;\n  [prop: string]: string | string[];\n};\n\nconst MAP_PREFIX = \"1PuQa7K62MiKCtssSLKy1kh56WWU7MtUR5\";\n\nconst buildInscription = (\n  destinationAddress: P2PKHAddress,\n  b64File?: string | undefined,\n  mediaType?: string | undefined,\n  metaData?: MAP | undefined\n): Script => {\n  let ordAsm = \"\";\n  // This can be omitted for reinscriptions that just update metadata\n  if (b64File !== undefined && mediaType !== undefined) {\n    const ordHex = toHex(\"ord\");\n    const fsBuffer = Buffer.from(b64File, \"base64\");\n    const fireShardHex = fsBuffer.toString(\"hex\");\n    const fireShardMediaType = toHex(mediaType);\n    ordAsm = `OP_0 OP_IF ${ordHex} OP_1 ${fireShardMediaType} OP_0 ${fireShardHex} OP_ENDIF`;\n  }\n\n  // Create ordinal output and inscription in a single output\n  let inscriptionAsm = `${destinationAddress\n    .get_locking_script()\n    .to_asm_string()}${ordAsm ? \" \" + ordAsm : \"\"}`;\n\n  // MAP.app and MAP.type keys are required\n  if (metaData && metaData?.app && metaData?.type) {\n    const mapPrefixHex = toHex(MAP_PREFIX);\n    const mapCmdValue = toHex(\"SET\");\n    inscriptionAsm = `${inscriptionAsm} OP_RETURN ${mapPrefixHex} ${mapCmdValue}`;\n\n    for (const [key, value] of Object.entries(metaData)) {\n      if (key !== \"cmd\") {\n        inscriptionAsm = `${inscriptionAsm} ${toHex(key)} ${toHex(\n          value as string\n        )}`;\n      }\n    }\n  }\n\n  return Script.from_asm_string(inscriptionAsm);\n};\n\nexport const buildReinscriptionTemplate = async (\n  ordinal: Utxo,\n  destinationAddress: string,\n  reinscription?: Inscription,\n  metaData?: MAP\n): Promise<Transaction> => {\n  let tx = new Transaction(1, 0);\n\n  // Inputs\n  let utxoIn = new TxIn(\n    Buffer.from(ordinal.txid, \"hex\"),\n    ordinal.vout,\n    Script.from_asm_string(ordinal.script)\n  );\n\n  tx.add_input(utxoIn);\n\n  // Outputs\n  const inscriptionScript = buildInscription(\n    P2PKHAddress.from_string(destinationAddress),\n    reinscription?.dataB64,\n    reinscription?.contentType,\n    metaData\n  );\n\n  let satOut = new TxOut(BigInt(1), inscriptionScript);\n  tx.add_output(satOut);\n\n  return tx;\n};\n\nexport type Payment = {\n  to: string;\n  amount: bigint;\n};\n\nconst createOrdinalFromFundingTx = async ({\n  fundingTx,\n  utxos,\n  destinationAddress,\n  changeAddress,\n  satPerByteFee,\n  inscription,\n  additionalPayments = [],\n  metadata,\n  signer\n}: {\n  fundingTx: Transaction;\n  utxos: Utxo[];\n  destinationAddress: string;\n  changeAddress: string;\n  satPerByteFee: number;\n  inscription: Inscription;\n  additionalPayments: Payment[];\n  metadata: MAP;\n  signer: LocalSigner;\n}): Promise<Transaction> => {\n\n  const tx = fundingTx;\n\n  // Outputs\n  const inscriptionScript = buildInscription(\n      P2PKHAddress.from_string(destinationAddress),\n      inscription.dataB64,\n      inscription.contentType,\n      metadata\n  );\n\n  let satOut = new TxOut(BigInt(1), inscriptionScript);\n  tx.add_output(satOut);\n\n  // add additional payments if any\n  for (let p of additionalPayments) {\n      let satOut = new TxOut(\n          p.amount,\n          P2PKHAddress.from_string(p.to).get_locking_script()\n      );\n      tx.add_output(satOut);\n  }\n\n  // total the outputs\n  let totalOut = 0n;\n  let numOuts = tx.get_noutputs();\n  for (const i of Array(numOuts).keys()) {\n      totalOut += tx.get_output(i)?.get_satoshis() || 0n;\n  }\n\n  // add change\n  const changeaddr = P2PKHAddress.from_string(changeAddress);\n  const changeScript = changeaddr.get_locking_script();\n  const fee = Math.ceil(\n      satPerByteFee * (tx.get_size() + P2PKH_OUTPUT_SIZE)\n  );\n  const change = BigInt(utxos.reduce((acc, curr) => acc + curr.satoshis, 0)) - totalOut - BigInt(fee);\n  if (change < 0) throw new Error(\"Inadequate satoshis for fee\");\n  if (change > 0) {\n      let changeOut = new TxOut(BigInt(change), changeScript);\n      tx.add_output(changeOut);\n  }\n\n  // sign tx if idKey or remote signer like starfish/tokenpass\n  const idKey = (signer as LocalSigner)?.idKey;\n  // input txids are available so sigma signature\n  // can be final before signing the tx\n  const sigma = new Sigma(tx);\n  const { signedTx } = sigma.sign(idKey);\n\n  return signedTx;\n};\n\nconst createOrdinal = async (\n  utxo: Utxo,\n  destinationAddress: string,\n  changeAddress: string,\n  satPerByteFee: number,\n  inscription: Inscription,\n  additionalPayments: Payment[] = [],\n  paymentPk?: PrivateKey,\n  metaData?: MAP,\n  fundingTx?: Transaction,\n  signer?: LocalSigner | RemoteSigner\n): Promise<Transaction> => {\n\n  let tx = fundingTx || new Transaction(1, 0);\n  let utxoIn\n\n  if (!fundingTx) {\n\n    // Inputs\n    utxoIn = new TxIn(\n      Buffer.from(utxo.txid, \"hex\"),\n      utxo.vout,\n      Script.from_asm_string(\"\")\n    );\n\n    tx.add_input(utxoIn);\n\n  }\n\n  // Outputs\n  const inscriptionScript = buildInscription(\n    P2PKHAddress.from_string(destinationAddress),\n    inscription.dataB64,\n    inscription.contentType,\n    metaData\n  );\n\n  let satOut = new TxOut(BigInt(1), inscriptionScript);\n  tx.add_output(satOut);\n\n  // add additional payments if any\n  for (let p of additionalPayments) {\n    let satOut = new TxOut(\n      p.amount,\n      P2PKHAddress.from_string(p.to).get_locking_script()\n    );\n    tx.add_output(satOut);\n  }\n\n  // total the outputs\n  let totalOut = 0n;\n  let numOuts = tx.get_noutputs();\n  for (const i of Array(numOuts).keys()) {\n    totalOut += tx.get_output(i)?.get_satoshis() || 0n;\n  }\n\n  // add change\n  const changeaddr = P2PKHAddress.from_string(changeAddress);\n  const changeScript = changeaddr.get_locking_script();\n  const fee = Math.ceil(\n    satPerByteFee * (tx.get_size() + P2PKH_OUTPUT_SIZE + (fundingTx ? 0 : P2PKH_INPUT_SCRIPT_SIZE))\n  );\n  const change = BigInt(utxo.satoshis) - totalOut - BigInt(fee);\n  if (change < 0) throw new Error(\"Inadequate satoshis for fee\");\n  if (change > 0) {\n    let changeOut = new TxOut(BigInt(change), changeScript);\n    tx.add_output(changeOut);\n  }\n\n  // sign tx if idKey or remote signer like starfish/tokenpass\n  const idKey = (signer as LocalSigner)?.idKey;\n  const keyHost = (signer as RemoteSigner)?.keyHost;\n  if (idKey) {\n    // input txids are available so sigma signature\n    // can be final before signing the tx\n    const sigma = new Sigma(tx);\n    const { signedTx } = sigma.sign(idKey);\n    tx = signedTx;\n  } else if (keyHost) {\n    const authToken = (signer as RemoteSigner)?.authToken;\n    const sigma = new Sigma(tx);\n    try {\n      const { signedTx } = await sigma.remoteSign(keyHost, authToken);\n      tx = signedTx;\n    } catch (e) {\n      console.log(e);\n      throw new Error(\"Remote signing to \" + keyHost + \" failed\");\n    }\n  }\n\n  if (!fundingTx && utxoIn && paymentPk) {\n\n    const sig = tx.sign(\n      paymentPk,\n      SigHash.ALL | SigHash.FORKID,\n      0,\n      Script.from_asm_string(utxo.script),\n      BigInt(utxo.satoshis)\n    );\n\n    utxoIn.set_unlocking_script(\n      Script.from_asm_string(\n        `${sig.to_hex()} ${paymentPk.to_public_key().to_hex()}`\n      )\n    );\n\n    tx.set_input(0, utxoIn);\n  }\n\n\n  return tx;\n};\n\nconst sendOrdinal = async (\n  paymentUtxo: Utxo,\n  ordinal: Utxo,\n  paymentPk: PrivateKey,\n  changeAddress: string,\n  satPerByteFee: number,\n  ordPk: PrivateKey,\n  ordDestinationAddress: string,\n  reinscription?: Inscription,\n  metaData?: MAP,\n  additionalPayments: Payment[] = []\n): Promise<Transaction> => {\n  let tx = new Transaction(1, 0);\n\n  // Inputs\n  let ordIn = new TxIn(\n    Buffer.from(ordinal.txid, \"hex\"),\n    ordinal.vout,\n    Script.from_asm_string(\"\")\n  );\n  tx.add_input(ordIn);\n\n  let utxoIn = new TxIn(\n    Buffer.from(paymentUtxo.txid, \"hex\"),\n    paymentUtxo.vout,\n    Script.from_asm_string(\"\")\n  );\n\n  tx.add_input(utxoIn);\n\n  let s: Script;\n  const destinationAddress = P2PKHAddress.from_string(ordDestinationAddress);\n  if (reinscription?.dataB64 && reinscription?.contentType) {\n    s = buildInscription(\n      destinationAddress,\n      reinscription.dataB64,\n      reinscription.contentType,\n      metaData\n    );\n  } else {\n    s = destinationAddress.get_locking_script();\n  }\n  let satOut = new TxOut(BigInt(1), s);\n  tx.add_output(satOut);\n\n  // add additional payments if any\n  for (let p of additionalPayments) {\n    let satOut = new TxOut(\n      p.amount,\n      P2PKHAddress.from_string(p.to).get_locking_script()\n    );\n    tx.add_output(satOut);\n  }\n\n  // total the outputs\n  let totalOut = 0n;\n  let numOuts = tx.get_noutputs();\n  for (const i of Array(numOuts).keys()) {\n    totalOut += tx.get_output(i)?.get_satoshis() || 0n;\n  }\n\n  // add change\n  const changeaddr = P2PKHAddress.from_string(changeAddress);\n  const changeScript = changeaddr.get_locking_script();\n\n  const fee = Math.ceil(\n    satPerByteFee *\n    (tx.get_size() + P2PKH_OUTPUT_SIZE + 2 * P2PKH_INPUT_SCRIPT_SIZE)\n  );\n  const change = BigInt(paymentUtxo.satoshis) - totalOut - BigInt(fee);\n  let changeOut = new TxOut(change, changeScript);\n\n  tx.add_output(changeOut);\n\n  // sign ordinal\n  const sig = tx.sign(\n    ordPk,\n    SigHash.InputOutput,\n    0,\n    Script.from_asm_string(ordinal.script),\n    BigInt(ordinal.satoshis)\n  );\n\n  ordIn.set_unlocking_script(\n    Script.from_asm_string(`${sig.to_hex()} ${ordPk.to_public_key().to_hex()}`)\n  );\n\n  tx.set_input(0, ordIn);\n\n  // sign fee payment\n  const sig2 = tx.sign(\n    paymentPk,\n    SigHash.InputOutput,\n    1,\n    Script.from_asm_string(paymentUtxo.script),\n    BigInt(paymentUtxo.satoshis)\n  );\n\n  utxoIn.set_unlocking_script(\n    Script.from_asm_string(\n      `${sig2.to_hex()} ${paymentPk.to_public_key().to_hex()}`\n    )\n  );\n\n  tx.set_input(1, utxoIn);\n\n  return tx;\n};\n\n// sendUtxos sends p2pkh utxos to the given destinationAddress\nconst sendUtxos = async (\n  utxos: Utxo[],\n  paymentPk: PrivateKey,\n  address: P2PKHAddress,\n  feeSats: number\n): Promise<Transaction> => {\n  const tx = new Transaction(1, 0);\n\n  // Outputs\n  let inputValue = 0;\n  for (let u of utxos || []) {\n    inputValue += u.satoshis;\n  }\n  const satsIn = inputValue;\n  const satsOut = satsIn - feeSats;\n  console.log({ feeSats, satsIn, satsOut });\n  tx.add_output(new TxOut(BigInt(satsOut), address.get_locking_script()));\n\n  // build txins from our UTXOs\n  let idx = 0;\n  for (let u of utxos || []) {\n    console.log({ u });\n    const inx = new TxIn(\n      Buffer.from(u.txid, \"hex\"),\n      u.vout,\n      Script.from_asm_string(\"\")\n    );\n    console.log({ inx });\n    inx.set_satoshis(BigInt(u.satoshis));\n    tx.add_input(inx);\n\n    const sig = tx.sign(\n      paymentPk,\n      SigHash.InputOutputs,\n      idx,\n      Script.from_asm_string(u.script),\n      BigInt(u.satoshis)\n    );\n\n    inx.set_unlocking_script(\n      Script.from_asm_string(\n        `${sig.to_hex()} ${paymentPk.to_public_key().to_hex()}`\n      )\n    );\n\n    tx.set_input(idx, inx);\n    idx++;\n  }\n  return tx;\n};\n\nexport const P2PKH_INPUT_SCRIPT_SIZE = 107;\nexport const P2PKH_FULL_INPUT_SIZE = 148;\nexport const P2PKH_OUTPUT_SIZE = 34;\n\nexport { buildInscription, createOrdinal, createOrdinalFromFundingTx, sendOrdinal, sendUtxos };\n"],"names":["LINE","_log","message","console","log","DotenvModule","config","options","dotenvPath","path","resolve","process","cwd","encoding","debug","Boolean","override","envPath","join","os","homedir","slice","parsed","parse","fs","readFileSync","Object","keys","forEach","key","prototype","hasOwnProperty","call","env","e","error","src","obj","match","lines","toString","replace","exec","value","trim","maybeQuote","config_1","parse_1","main","toHex","asciiStr","arr1","n","l","length","hex","Number","charCodeAt","push","dotenv","buildInscription","destinationAddress","b64File","mediaType","metaData","ordAsm","undefined","ordHex","fireShardHex","Buffer","from","fireShardMediaType","inscriptionAsm","get_locking_script","to_asm_string","app","type","mapPrefixHex","mapCmdValue","_i","_Object$entries","entries","_Object$entries$_i","Script","from_asm_string","ordinal","reinscription","tx","Transaction","utxoIn","TxIn","txid","vout","script","add_input","inscriptionScript","P2PKHAddress","from_string","dataB64","contentType","satOut","TxOut","BigInt","add_output","Promise","reject","utxo","changeAddress","satPerByteFee","inscription","additionalPayments","paymentPk","fundingTx","signer","_temp2","_result3","sig","sign","SigHash","ALL","FORKID","satoshis","set_unlocking_script","to_hex","to_public_key","set_input","_step3","_iterator3","_createForOfIteratorHelperLoose","done","p","amount","to","_step4","totalOut","numOuts","get_noutputs","_iterator4","Array","_tx$get_output2","get_output","get_satoshis","changeScript","fee","Math","ceil","get_size","change","Error","changeOut","idKey","keyHost","_temp","authToken","sigma","Sigma","remoteSign","then","_ref2","signedTx","_catch","_sigma$sign2","_ref","utxos","_ref$additionalPaymen","metadata","_step","_iterator","_step2","_iterator2","_tx$get_output","reduce","acc","curr","_sigma$sign","paymentUtxo","ordPk","ordDestinationAddress","ordIn","s","_step5","_iterator5","_step6","_iterator6","_tx$get_output3","InputOutput","sig2","address","feeSats","_step7","inputValue","_iterator7","satsOut","satsIn","_step8","idx","_iterator8","u","inx","set_satoshis","InputOutputs"],"mappings":"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"}